JAVA CONTENTS
=============
1.JAVA TYPES
2.JAVA HISTORY
3.DIFFERENCE BETWEEN JAVA AND OTHERS
4.JAVA FEATURES
5.JAVA NAMING CONVENTIONS
6.JAVA PROGRAMMING FORMAT
7.FIRST JAVA APPLICATION
8.LANGUAGE FUNDAMENTALS
9.TYPE CASTING
10.CONDITIONAL STATEMENTS
11.ITERATIVE STATEMENTS
12.TRANSFER STATEMENT
13.ARRAYS
14.OBJECT ORIENTED FEATURES OVERVIEW
15.CONTAINERS
Class/Abstract Class/Interface
16.METHODS
17.OBJECT 
18.CONSTRUCTORS
19.INSTANCE CONTEXT
20.THIS KEYWORD
21.STATIC KEYWORD
22.STATIC CONTEXT
23.CLASS.FORNAME()
24.NEWINSTANCE()
25.SINGLETON CLASS
26.FINAL KEYWORD
27.ENUM
28.MAIN METHOD
29.INHERITANCE
30.SUPER KEYWORD
31.CLASS LEVEL TYPE CASTING
32.POLYMORPHISM
33.ABSTRACT CLASS
34.WRAPPER CLASS
35.PACKAGES
36.ARRAYS
37.STRINGS
38.LABMDA EXPRESSION
39.EXCEPTION HANDLING
40.COLLECTIONS

************************************************************************************************************************************************************
Day 1,2,3

JAVA TYPES
==========
J2SE/Java SE
->To create Standalone application

J2EE/Java EE
->Server side programming
->Distributed applications/Enterprise applications
->Client Server architecture applications

J2ME/Java ME
->Mobile applications

************************************************************************************************************************************************************
JAVA HISTORY
============
->James Gosling and Patrick Naughtan
->3 major features
Simple PL [Less exe time, memory.power consumptions]
Tight coded PL [Less code]
Architecture neutral PL [Hardware neutral]
->1996 Jan 27 Java 1.0/JDK 1.0

************************************************************************************************************************************************************
Day 4

DIFFERENCE BETWEEN JAVA AND OTHERS
==================================

1. Java is Dynamic PL
---------------------
->Allow memory allocation for the Primitive data types vaiables at Runtime
->Objects created at Runtime

Java Execution
--------------
.Java->[Compilation][Compiler][Compilation Time/Static Time]->Low level language/Machine level language/Byte Code/.Class file->[Translate to Native code and Execute][JVM][Runtime/Dynamic Time]->Output

->Compilation
Error check
Translate HLL to LLL

2. No Preprocessors in Java
---------------------------
->All Pre def library are given inform of Classes and Interfaces inside Packages.
->Can be used any Pre defined library directly in Java program using import statments

Ex:
import java.io.*
import java.sql.*

->Compiler check these packages are avl in Java software or not during compilation time, If not avl then it throws package xxx does not exist.
->Compiler will not load any packages in to the memory.
->During execution JVM will load only required library into the memory during Runtime

3.Java is Platform Independant PL
---------------------------------
->Compile in one OS and Execute in another OS[WORA]
->Byte code, is not directly exe code, it will be converted and exe in any OS system.
->Internally JVM will have a Translator to do this conversion before execution.
->Java program is Platform independant but JVM is Platform dependant.

4.Multiple Inheritence is not possible in Java
----------------------------------------------
->Any PL represents data in form of Objects as per Object oriented features then it is Object Oriented PL
->Inheritance is relation between classes, it provides variables and methods of one class to other classes.
->Used for Code reusability

Super Class<--extends--Sub Class

5.Garbage collector in Java
---------------------------
->Create Object, Store data, Process data, Destroy Object
->Constructor are used to create Object
->GC to destroy Object, when there is no reference to the Object.

6.Fixed memory allocation for Primitive data types irrespective of the OS
-------------------------------------------------------------------------
byte 1 bytes
short 2 bytes
int 4 bytes 
long 8 bytes
float 4 bytes
double 8 bytes
char 2 bytes
boolean 1 bit

->In Java all character are represented inform of UNICODE [Represent all the natural lang characters]

************************************************************************************************************************************************************
Day 10

JAVA FEATURES
=============
Simple,OOPL,Platform Ind,Arch netutral,Portable,Robust,Dynamic,Distribted,Secured,Multiprogramming,HighPerf,Interpretive

************************************************************************************************************************************************************
Day 13

JAVA NAMING CONVENTIONS
=======================
->Case sensitive PL

Recommended Rules
-----------------
Class/Abstract Class/Interface - Start with Upper case and subsequent symbls should be upper case
Method/Variable- Start with Lower case and subsequent symbls should be upper case
Package-Lower case
Constants-Upper case

************************************************************************************************************************************************************
Day 13

JAVA PROGRAMMING FORMAT
=======================

Comment[Optional]
Package[Optional]
Import[Optional]
Calss/Interface[Optional]
Main Class[Mandatory]

Comments
--------
Single line 
//

Multi line
/*
*/

Package
--------
->Java is collection of API->API is collection of Packages->Package is collection of Classes and Interfaces->Classes and Interfaces is collection of Variables and Methods
->Package is collection of related classes and interfaces as single unit
->Folder contains .class files represent related classes and interfaces

Ex:java.lang/java.io/java.util

->Types
Pre defined
User defined

Ex:
package p1
package p1.p2.p3

->Conditions
Package name should be first line
Package name should be unique

->Syntax
company name in rev . project name . module name . submodule name

Import 
-------
->Make avl specific or all classes or interfaces of a package to present java program.

NOTE:For each and every class,Interface, AC, Enums, Inner class seperate .class file will be created on compilation.
All these .class files will be saved inside the package folder

import packagename.* 
import java.io.*

import packagename.memberName
import java.util.ArrayList

->Using Classes and Interfaces of any specific package without importing in any specific java file
Fully Quaified name ->packageName.memberName
Example:java.util.List list=new java.util.ArrayList();

Main Class
----------
->Class having main method
->Contains App Logic, executed by JVM automatically
->Start and End point of the Program execution
************************************************************************************************************************************************************
Day 17

FIRST JAVA APPLICATION
======================

Setup
-----
->Download and Install JDK
->Set env variable
Copy path include bin and paste in path env variable value

package basics1;

public class HelloWorld {

	public static void main(String[] args) {

		System.out.println("Hello Appu !");

	}

}

Save File
---------
->Public class name, if not avl then use class name having main method.
->No 2 class can be public in same java file.

Compile
-------
->Check error and convert HLL to .class files
->For each and every class,Interface, AC, Enums, Inner class seperate .class file will be created on compilation.
->All these .class files will be saved inside the package folder

Execute
-------
->JVM will create main thread and starts executing main method logic
->After execution all the resouce will be released and thread will move to dead state

************************************************************************************************************************************************************
Day 24

LANGUAGE FUNDAMENTALS
====================
Tokens/Data types/Type casting/Java statements/Arrays

Tokens
------
Identifiers/Literals/Keywords/Operators

Identifiers Rules:
Start with Character or _ or $
No spaces, can use _
Operators, Keywords, Primitive data types not allowed
No special symbols except $ and _

Literals
--------
Integrals/Floating point/Boolean/String Literals

Number Systems
--------------
Binary
0 or 1
Prefix: 0b or 0B
Ex:int b=0b1010

Octal
0-7
Prefix: 0[Zero]
Ex:int b=02345

Decimal
0-9
Prefix: NA
Ex:int c=2345

Hexadecimal
0-9,A,B,C,D,E,F
Prefix: 0x or 0X
Ex:int b=0X234AB

Note: Output always will be in decimal format

Operators
--------
Logical Boolean Operator: & | ^
Logical Bitwise operator:<< >> & | ^

Left shift:<<
->Convert to binary
->Remove n symbol from left  and add n 0's at right
->Convert to decimal

Short circuit operator: && ||

Ternary operator: exp1?exp2:exp3;
Ex:
int a = 20, b = 30, c;
c = a > b ? a : b;
System.out.println("Big is:" + c); //30

a=a+2 or a+=2;

Data types
----------
->To identify memory size and range 

Types:
Primitive/Primary Data types
byte[1 bytes/0]
short[2 bytes/0]
int[4 bytes/0]
long[8 bytes/0L]
float[4 bytes/0.0f]
double[8 bytes/0.0]
char[2 bytes/' ']
boolean[1 bit/false]

User defined/Secondary Data types
->No fixed memory size, depends on the data.
->Default value is null

public class Rough {

	static String str;

	public static void main(String[] args) {
		System.out.println(str);//null

	}

}

->To find the range
public class Rough {
	public static void main(String[] args) {
		System.out.println(Byte.MIN_VALUE + " " + Byte.MAX_VALUE); //-128 to 127

	}

}

************************************************************************************************************************************************************
Day 32

TYPECASTING
===========
->Converting data from one type to another type
Types:
Primitive Data Type Typecasting
Userdefined Data Type Typecasting

Primitive Data Type Typecasting
-------------------------------
Implicit/Widening
Lower to Higher type conversion

byte->short->int->long->float->double
char->int

->Compiler check type compatibility[Type checking], JVM assign vaues from RHS to LHS[Type casting].

Higher <-Lower //No Error
Ex:
byte b=10;
int i=b; 


Explicit/narrowing
Higher to Lower type conversion

Lower <-Higher //CT Error
Lower<-(X)Higher //X data type<=LHS data type
Ex:
int i=10;
byte b=i; //CT Error, i>b
byte b=(byte) i; 

************************************************************************************************************************************************************
Day 35

CONDITIONAL STATEMENTS
======================

IF Statements
-------------
if(cond)
{
Statments
}
else if(cond)
{
Statments
}
else
{
Statments
}

->Local var should be initialized before use
->Compiler will evaluate Constant condition, JVM will evaluate variable condition

public class ConstantExpEvaluationByCompiler {

	public static void main(String[] args) {
		
		int i=10,j;
		
		if(i==10)
		{
			j=20;
		}
		
		System.out.println(j); //CT ERROR, there may be chances if block could fail and j may not get value

	}

}

public class ConstantExpEvaluationByCompiler {

	public static void main(String[] args) {

		final int i = 10;
		int j;

		if (i == 10) { //Evaluated by Compiler
			j = 20;
		}

		System.out.println(j); //20

	}

}

Swith Statement
---------------
->byte,short,char,int,string Allowed data types

switch( var)
{
case 1:
Statement;
break;

case 1:
Statement;
break;

default:
Statement;

}

Ex:
public class SwitchDemo {

	public static void main(String[] args) {

		int day = 2;

		switch (day) {
		case 1:
			System.out.println("Monday");
			break;

		case 2:
			System.out.println("Tuesday");
			break;

		case 3:
			System.out.println("Wednesday");
			break;

		default:
			System.out.println("Invalid");
		}

	}

}

************************************************************************************************************************************************************
Day 38

ITERATIVE STATEMENTS
====================
for/while/do while

for(arrayDataType varname:refVarname)
{
}

Ex:
public class FoerEachDemo {

	public static void main(String[] args) {
		
		int a[]= {2,3,4,5};
		
		for(int x:a)
		{
			System.out.println(x);
		}

	}

}

while(cond)
{
Statements
}


do
{
Statements
}while(conditions);

************************************************************************************************************************************************************
Day 42

TRANSFER STATEMENT
==================
break/continue/return

->Bypass flow of exe from one isntauction to another instruction
->break:Used inside Switch and Loops[Only for current loop in case of nested loops]
->Labled break: To apply break to specific loop

public class LabeledBreakStatement {

	public static void main(String[] args) {
		
		l1:for(int i=0;i<10;i++)
		{
			for(int j=0;j<5;j++)
			{
				if(j==3)
				{
					break l1;
				}
				System.out.println(i+" "+j);
			}
		}

	}

}

OUTPUT:
0 0
0 1
0 2

Same cases hold good for continue
************************************************************************************************************************************************************
Day 43

ARRAYS
======

Single Dimension Array
----------------------
Syntax:

dataype []var=new datatype[size];
var[0]=val1;

datatype []var={val1,val2};

1D Array
public class ArraySDemo {

	public static void main(String[] args) {

		int[] a = new int[5];
		a[0] = 10;
		a[1] = 20;
		a[2] = 30;
		a[3] = 40;
		a[4] = 50;

		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + " ");
		}

	}

}

Multi Dimension Array
---------------------
->Represent data in more than one dimension

Syntax:
int[][] a={{1,2,3},{4,5,6},{7,8,9}};

int[][] a=new int[2][3];
a[0][0]=10;
a[0][1]=20;
a[0][2]=30;

a[1][0]=40;
a[1][1]=50;
a[1][2]=60;

Ex:
public class MultiDimenArray {

	public static void main(String[] args) {

		int[][] a = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };

		for (int[] x : a) {
			for (int y : x) {
				System.out.print(y+" ");
			}
			System.out.println();
		}
	}

}

OUTPUT:
1 2 3 
4 5 6 
7 8 9 

public class MultiDimArray2 {

	public static void main(String[] args) {

		int[][] a = new int[2][3];
		a[0][0] = 10;
		a[0][1] = 20;
		a[0][2] = 30;

		a[1][0] = 40;
		a[1][1] = 50;
		a[1][2] = 60;

		for (int[] x : a) {
			for (int y : x) {
				System.out.print(y + " ");
			}
			System.out.println();
		}

	}

}

OUTPUT:
10 20 30 
40 50 60 

************************************************************************************************************************************************************
Day 54

OBJECT ORIENTED FEATURES OVERVIEW
=================================
Class/Object/Encapsulation/Abstraction/Inheritece/Polymorphism/Messsage passing

CONTAINERS
==========
->Java elements contains Varibales,Blocks,Methods,...

Types:
Class/Abstract Class/Interface/Enum

************************************************************************************************************************************************************
Day 55

CLASS
=====
->To represent entities
Data->Variables
Behaviour->Methods

[access modifiers] class className [extends 0 or 1 Super Class] [implements 0 or N Interafces]
{
variables
methods
constructors
blocks
enums
interfaces
abstract classes
classes
}

Access Modifiers
----------------
->To provide scopes and extra nature to programming elements

Types
Scopes AM[public/private/protected/default]
Special power AM [static/final/volatile/abstract/native/synchronized/strictfp/...]

public:can be accessed any where within the project
protected:can be accessed in same package and child of other package
default:can be accessed in same package
private:can be accessed in same class

->For outer class only public and default allowed
->For inner class all 4 allowed
->For outer class final,abstract and strictfp are allowed
->For inner classs [static/final/abstarct/native/strictfp] are all allowed
->Instance var can be accessed using ref var and static var can be accessed using ref var or class name

Ex:
class Employee {
	int id = 100;
	String name = "Appu";

	public void display() {
		System.out.println("Employee details");
		System.out.println("Name:" + name);
		System.out.println("ID:" + id);
	}
}

public class ClassDemo {

	public static void main(String[] args) {

		Employee e1 = new Employee();
		e1.display();

	}

}
************************************************************************************************************************************************************
Day 58

METHODS
=======
->2 type[Concrete:Both declaration and body and Abstract:Only Declaration]
->
public void add(int a,int b)
{
}

public abstract void add(int a, int b);

->Con method avl in class and abstract classes, Abs method avl only in Interfaces

ABSTRACT CLASS
==============
->Class contains 0 or N abstract and or concrete methods
->Cannot create Object, only ref var declaration is avl
->If we declare ref var for abstract class then we can able to access only abstract class memebers
->If we declare ref for imp class then we can able to access members of both abstract and imp class
->If any method has variable declaration for different classes then declare it as abstract method

Ex:

abstract class Student {
	public abstract void mathsMarks();

	public void scienceMarks() {
		System.out.println("FC");
	}
}

class Appu extends Student {
	@Override
	public void mathsMarks() {
		System.out.println("FCD");
	}

	public void display() {
		System.out.println("Result displayed");
	}

}

public class AbstractClassDemo {

	public static void main(String[] args) {

		Student s = new Appu();
		s.mathsMarks();
		s.scienceMarks();

		Appu a = new Appu();
		a.mathsMarks();
		a.scienceMarks();
		a.display();

	}

}

************************************************************************************************************************************************************
Day 59

INTERFACE
=========
->Contains 0 or N abstract methods, default methods, private methods and static methods
->Cannot create Object
->All variables are public static final, can be accessed through Interface name, Sub class name, reference variable
->All methods are public and abstract

interface Shapes {
	int a = 10;
	void display();

}

class Sub implements Shapes
{

	@Override
	public void display() {
		System.out.println("A value is:"+a);
		
	}
	
}
public class InterfaceDemo {

	public static void main(String[] args) {
		
		Shapes s=new Sub();
		s.display();
		System.out.println(s.a);
		System.out.println(Shapes.a);

	}

}
************************************************************************************************************************************************************
Day 60

METHODS
=======

[Access modifiers] returnType methodName([paramList]) [throws exceptionList]
{
...........
...........
...........
[retrun value];

}

Access modifiers
----------------
->public,protected,default,private -only one allowed
->static,final,abstract,volatile,native,synchronized and strictfp -multiple allowed
Ex:static final void m1(){....}

Return type
-----------
->All primitive, userdefined data type and void are allowed

Paam list
---------
->All primitive, userdefined data type are allowed

throws
------
->To bypass the exception from called function to calling function to handles it.

Types
-----
->Accessor[getter():Used to get the data from the variables] and Mutator[setter():Used to set the data for the variables]

Ex:
class DataSetter {
	private String name;
	private int id;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}

}

public class GetterAndSetter {

	public static void main(String[] args) {

		DataSetter ds1 = new DataSetter();
		ds1.setId(100);
		ds1.setName("Appu");

		DataSetter ds2 = new DataSetter();
		ds2.setId(101);
		ds2.setName("Shivu");

		System.out.println("Details are:");
		System.out.println(ds1.getId() + ":" + ds1.getName());
		System.out.println(ds2.getId() + ":" + ds2.getName());

	}

}

Variable Arg Method
-------------------
->Syntax

returnType methodName(dataType...varName)
{

}

->varName acts like an array element
->Other parameter also allowed but it should be at begining
void add(int x,int... i) 
{
}
->Only one var arg parameter is allowed

Ex:
public class VarArgMethodDemo {

	void add(int... i) {
		System.out.println("Length is: " + i.length);
		for (int x : i) {
			System.out.print(x + " ");

		}
		System.out.println();

	}

	public static void main(String[] args) {

		VarArgMethodDemo v = new VarArgMethodDemo();
		v.add(1, 2, 3, 4);
		v.add(1);
		v.add();
	}

}

OUTPUT:
Length is: 4
1 2 3 4 
Length is: 1
1 
Length is: 0

************************************************************************************************************************************************************
Day 62

OBJECT 
======
->To store instance var data in the heap memory and to access instance members.

className refVarName=new className([parametervalues]);

Ex:
Employee employee=new Employee();

Object creation process
-----------------------
Complie
->For each and every class/enum/ac/interface seperate .class files will be generated

Execute:
->JVM will be activated
->Loads required classes .class files into method area, create an object for java.lang.Class and stores all the meta data of the respective class into it.
->Creates main thread to execute main method.
->Main thread stack will be created in Stack area, for ech method seperate activation record will be created inside it[stores all the local var inside it]
->JVM calculates memory required to store insatnce var data and inform to heap manager.
->Heap manager, allocates free memory space in Heap memory and assign integer value to it known as Hash code
->JVM will convert hash code to reference value and stores in reference variable
->Rererence variable will be stored in Stack memory
->JVM checks for instance var values inside class or constructor, if exist then stores into heap memory else loads default values
->Instance var:Heap/Local var:Stack/Ref var:Stack

->To get hashcode value and reference value
ObjectDemo o = new ObjectDemo('A');
System.out.println(o.hashCode());
System.out.println(o);

OUTPUT:
125993742
oops1.ObjectDemo@782830e


Ex:
class ObjectDemo {

	int a;
	String str = "Appu";
	float f = 2.33f;
	char c;
	int x = 100;

	ObjectDemo(char c) {
		f = 3.33f;
		this.c = c;
	}

	public void display() {
		int x = 10;

		System.out.println(a);
		System.out.println(str);
		System.out.println(f);
		System.out.println(c);
		System.out.println(x);
	}

}

public class ObjectCreation {

	public static void main(String[] args) {

		ObjectDemo o = new ObjectDemo('A');
		o.display();

	}

}

OUTPUT:
0
Appu
3.33
A
10

Object Types
------------
Mutable and Immutable Objects
->Mutable Object: Allows modification on data in same memory Ex:StringBuffer
->Immutable Obejct:Not allows modification on data in same memory, if performed new memory will be created and stores modifed data there Ex:String

Ex:

public class MutableVsImmutableObjects {

	public static void main(String[] args) {

		String str1 = new String("Punith");
		String str2 = str1.concat("Rajkumar");
		System.out.println(str1);
		System.out.println(str2);
		System.out.println(str1.hashCode());
		System.out.println(str2.hashCode());

		System.out.println("***************************");

		StringBuffer sb1 = new StringBuffer("Punith");
		StringBuffer sb2 = sb1.append("Rajkumar");
		System.out.println(sb1);
		System.out.println(sb2);
		System.out.println(sb1.hashCode());
		System.out.println(sb2.hashCode());
	}

}

OUTPUT:
Punith
PunithRajkumar
-1893201644
-255794771
***************************
PunithRajkumar
PunithRajkumar
1910163204
1910163204

Object vs Instance
------------------
->Instance:Object at any specific point of time
************************************************************************************************************************************************************
Day 65

CONSTRUCTORS
============
->Used to create object and initialize instance variable data while creating an object itself.
->Executed at time of creating object
->No return type and name same as class name.
->Allows public,private,default,protected,throws.
->static,final,abstract,...not allowed
->Cannot be overrided, can be overloaded
->If we create private consructor then we cannot able to create object outside of the class

Syntax
------
[accessModifiers] className ([parameterList])
{
}

Types
-----
Contructor [Default:zero arg and User defined: zero arg/parameterized const]

Default Constructor:If dev not explicitly speified the constructor then compiler will create one default zero arg constructor.
User def Constructor: Constructor provided by Dev with or without arguement
************************************************************************************************************************************************************
Day 66

INSTANCE CONTEXT
================
->While loading .class file to memory by JVM, static context will be created. 
->When Object is created [Constructor executed], Instance context will be created.

Instance variables
------------------
->Non static class level variables
->Variables types[Local[Stack] and Class level [Static[Method area]/Non Static or Instance[Heap]]
->Instance variables will be stored in heap memory
->In current class we can access instance variables directly, but from other class we need to create an Object.
->If we access instance var using ref var containing null value then it throws null pointer exception
->For every object seperate copy of instance var data will be created
->Instance var are recognized and executed just before executing constructor.

Ex: Static context vs Instance context

class Instance {
	static int a;
	int b;

}

public class InstanceContext {

	public static void main(String[] args) {

		Instance i1 = new Instance();
		Instance i2 = new Instance();

		i1.a = 100;
		i1.b = 200;
		System.out.println(i1.a + " " + i1.b);

		i2.a = 10;
		i2.b = 20;
		System.out.println(i2.a + " " + i2.b);

		System.out.println(i1.a + " " + i1.b);

		i2 = null;
		i2.a = 200;

	}

}

OUTPUT:
100 200
10 20
10 200

Instance methods
----------------
->Non static method inside the class
->In current class we can access instance method directly, but from other class we need to create an Object.
->If we access instance method using ref var containing null value then it throws null pointer exception

Insatnce block
--------------
->Instance block are recognized and executed just before executing constructor.
Syntax:
{
..............
..............
}


Flow of Exe:
Inst Block or var [FCFS]
Const1
Inst Block or var [FCFS]
Const2

************************************************************************************************************************************************************
Day 67

THIS KEYWORD
============
->To refer current class object/members
->Used to refer [Current class variables/methods/constructor] and to return current class object

To refer current class variables
--------------------------------
->this.varName
->Var search:Local>Class>Super Class>Object Else Error

class This {
	int a = 10;

	void m1() {
		int a = 20;
		System.out.println(a);
		System.out.println(this.a);
	}
}

public class AccesVarUsingThis {

	public static void main(String[] args) {

		This t = new This();
		t.m1();

	}

}

OUTPUT:
20
10

To refer current class constructor
----------------------------------
->this([paramList]);
->Can be used only inside constructor and shoulb be in first statement only

class This1 {
	This1() {
		this(10);
		System.out.println("Zero Arg COnst");
	}

	This1(int a) {
		this(12.3f, 11.4f);
		System.out.println("Int Arg COnst");
	}

	This1(float f, float y) {
		System.out.println("Float Arg COnst");
	}

}

public class ReferCurrentClassCOnstUsingThis {

	public static void main(String[] args) {
		This1 t = new This1();

	}

}


OUTPUT:
Float Arg COnst
Int Arg COnst
Zero Arg COnst

To return current class object from the method
----------------------------------------------
->How many time JVM executes new Keyword that number of times object will be created.

class This2 {
	This2 getRef() {
		return this;
	}

	void disp() {
		System.out.println("This 2 Class");
	}
}

public class ReturnCurrentClassObjectUsingThis {

	public static void main(String[] args) {

		This2 t = new This2();
		System.out.println(t);
		t.disp();

		This2 t1 = t.getRef();
		System.out.println(t1);

	}

}

OUTPUT:
oops1.This2@5d22bbb7
This 2 Class
oops1.This2@5d22bbb7

************************************************************************************************************************************************************
STATIC KEYWORD
==============
->Static variable/Method/Block/Import

Static variables
----------------
->Recognized and Initialized while loading .class file into method area.
->Same value will be shared with all the Objects
->Modification from one object will be reflected to all the objects.
->Static variables should be declared at class level, Local var cannot be static variables
->Can be accessed using reference variable or through class name
->No null pointer exception
->Can be accessed using this keyword
->Same value to be shared across all the objects then store it in static variable
->Class specific

->We can able to access static variables directly in both instance and static method. but instance variables can be accessed only inside instance method.If we want to access instance variables inside static method we need to create an object and access.

Ex:
class Static {
	static int a = 10;
	int b = 20;

	void m1() {
		System.out.println(a);
		System.out.println(b);
	}

	static void m2() {
		System.out.println(a); 
		System.out.println(b); //ERROR
	}
}

SOLUTION

class Static {
	static int a = 10;
	int b = 20;

	void m1() {
		System.out.println(b);
		System.out.println(a);
	}

	static void m2() {
		
		Static s=new Static();
		System.out.println(s.b); //NO ERROR
		System.out.println(a);
	}
}

Static Methods
--------------
->Can contains only static members of the current class.
->We can access instance members by creating object, but cant contain in it.
->No null pointer exception
->Not allow this keyword in their body but we can use this keyword to access current class static methods.

Ex:
class Static {
	static int a = 10;
	int b = 20;

	void m1() {
		System.out.println(b);
		System.out.println(a);
	}

	static void m2() {
		
		Static s=new Static();
		System.out.println(s.b);
		System.out.println(a);
		this.m1();
	}
}

Static Block
------------
->Recognized and initialized when loading .class file into memory.
->Contains only static members of the current class
->We can access instance members by creating object, but cant contain in it.
->Not allow this keyword in their body but we can use this keyword to access current class static methods.

Ex:
public class StaticBlock {

	int a = 10;
	static int j = 100;
	static {
		System.out.println("Welcome");
		System.out.println(j);

		StaticBlock sb = new StaticBlock();
		System.out.println(sb.a);
	}

	public static void main(String[] args) {

	}
}

Static Import
-------------
->If we want to access any static members of any class in present java file without class name or refrence variable then we need to do static import.
->Just import, we can access static members using class name or creating ref var, but if we do static import then we can directly access without class name or ref var

import static packageName.className.memberName;
import static packageName.className.*;

Ex:
package Programs;

public class StaticClass {

	public static int a=100;
	
	public static void dispaly()
	{
		System.out.println("Static");
	}
}

package oops1;

import static Programs.StaticClass.*;

public class StaticImport {

	public static void main(String[] args) {
		System.out.println(a);
		dispaly();

	}

}

***********************************************************************************************************************************************************
STATIC CONTEXT
==============
->Static var and blocks will be recognized and initialized when loading .class file to memory and only once per class.
->When Object created
Class byte code will be loaded to memory
Static context will be executed
Instance context will be executed
Constrcutor will be executed


Static var/blocks
Instance var /blocks
Constructor
Instance var /blocks
Constructor

Ex:
class SIContext {
	static {
		System.out.println("SB");
	}
	static int a = m1();

	static int m1() {
		System.out.println("SM");
		return 10;
	}

	int b = m2();

	{
		System.out.println("IB");
	}

	int m2() {
		System.out.println("IM");
		return 20;
	}

}

public class StaticInsatnceContext {

	public static void main(String[] args) {
		SIContext s1 = new SIContext();
		SIContext s2 = new SIContext();

	}

}

OUTPUT:
SM
SB
IM
IB
IM
IB

************************************************************************************************************************************************************
Day 70

CLASS.FORNAME()
=============
->When creating obj to the class, byte code will be loaded to the memory. But to load byte code to memory without creating Object to the class we can use 
forName()
->Loads class byte code and execute static context.

public static Class forName(String className) throws ClassNotFoundException
{
}

class ForName {

	ForName() {
		System.out.println("Const");
	}

	static {
		System.out.println("SB");
		// System.out.println(a);
	}

	static int a = m1();

	static int m1() {
		System.out.println("M1");
		return 10;
	}
}

public class ForNameMethodDemo {

	public static void main(String[] args) throws ClassNotFoundException {

		Class cls=Class.forName("oops1.ForName");
		System.out.println(cls.getName());
	}

}

OUTPUT:
SB
M1
oops1.ForName 

***********************************************************************************************************************************************************
NEWINSTANCE()
=============
->If we load byte code for any class using forName() and to create an object for the class then we will use newInsatnce()

public Object newInsatnce() throws Instattiation,IllegalAccessExceptio
{
}

Ex:
class ForName {

	ForName() {
		System.out.println("Const");
	}

	static {
		System.out.println("SB");
		// System.out.println(a);
	}

	static int a = m1();

	static int m1() {
		System.out.println("M1");
		return 10;
	}

	int b = m2();

	{
		System.out.println("IB");
	}

	public int m2() {
		System.out.println("M2");
		return 20;
	}
}

public class ForNameMethodDemo {

	public static void main(String[] args)
			throws ClassNotFoundException, InstantiationException, IllegalAccessException {

		Class cls = Class.forName("oops1.ForName");
		System.out.println(cls.getName());

		Object obj = cls.newInstance();

	}

}


OUTPUT:
SB
M1
oops1.ForName
M2
IB
Const

************************************************************************************************************************************************************
Day 71

SINGLETON CLASS
===============
->Any class allows to create single object 

Ex:Private Constructor

class Temp {
	private Temp() {

	}

	void m1() {
		System.out.println("M1");
	}

	static Temp getRef()
	{
		return new Temp();
	}
}

public class PrivateCostructor {

	public static void main(String[] args) {
		 Temp.getRef().m1();

	}

}

->Factory method design pattern: Method which return class reference value
->Types:Static and Instance factory method

Ex:
	static Temp getRef()
	{
		return new Temp();
	}

Ex:Singleton Class Case 1
class Sigleton {

	private Sigleton() {

	}

	static Sigleton s = null;

	static Sigleton getRef() {
		if (s == null) {
			s = new Sigleton();
		}
		return s;

	}

}

public class SingleTonClass {

	public static void main(String[] args) {

		Sigleton s1 = Sigleton.getRef();
		Sigleton s2 = Sigleton.getRef();

		System.out.println(s1);
		System.out.println(s2);

	}

}

OUTPUT:
oops1.Sigleton@5d22bbb7
oops1.Sigleton@5d22bbb7

Ex:Singleton Class Case 2
class SingletonDemo {

	private SingletonDemo() {

	}

	static SingletonDemo s = null;

	static {
		s = new SingletonDemo();
	}

	static SingletonDemo getRef() {
		return s;
	}
}

public class SingletonCase2 {

	public static void main(String[] args) {

		System.out.println(SingletonDemo.getRef());
		System.out.println(SingletonDemo.getRef());
	}

}
************************************************************************************************************************************************************
Day 72

FINAL KEYWORD
============
->Final variable:No modification/Should be initialized/Constant variable/can be accessed using reference var or class name
->Final method:No Overriding
->Final class:No Inheritance

->Declare constant variable as 
public static final dataType varName=value;
public static final int a=100;


Ex:

final class College {

        final int a=100;
	final public void display() {
		System.out.println("College");
	}
}

class Clas extends College {
	@Override
	public void display() {
		System.out.println("Class");
	}
}

public class FinalMethod {

	public static void main(String[] args) {
		

	}

}

***********************************************************************************************************************************************************
ENUM
====
->Container used to declare constant variables
->All constant avr by default are public static final
->All constant avr are enum type by default
->All constant variables are named constant variables, it dispalys names when we accessed
->No Inheritance
->Inside enum we can declare normal methods, var, cons along with constant variables.

Syntax:
[Access modifiers] enum enumName
{
List of constants
}

AM:public/private/default/protected

enum EnumDemos
{
	AVAILABLE,BUSY;
}
public class EnumDemo {

	public static void main(String[] args) {
		System.out.println(EnumDemos.AVAILABLE);
		System.out.println(EnumDemos.BUSY);

	}

}

OUTPUT:
AVAILABLE
BUSY

Ex:
enum EnumDemo2 {

	A(111), B(222);

	private int price;

	EnumDemo2(int price) {
		this.price = price;
	}

	public int getPrice() {
		return price;
	}

	public static void main(String[] args) {

		System.out.println(EnumDemo2.A.getPrice());
		System.out.println(EnumDemo2.B.getPrice());

	}

}

OUTPUT:
111
222

************************************************************************************************************************************************************
Day 73

MAIN METHODS
============
->Conventional method

public static void main (String[] args)
{
}

************************************************************************************************************************************************************
Day 74,75,78

RELATIONSHIP IN JAVA
====================
HAS-A : Association
IS-A:Inheritance

************************************************************************************************************************************************************
Day 78

INHERITANCE
===========
->One class[Sub Class] make using another class[Super Class] members without creating an object.
->Using Sub class ref var we can access both Super and Subclass memebrs, but using Super class ref var we can access only Super class memebrs.
->Code reusability.
->Multiple/Hybrid Inheritance is not possible due to ambiguity problem

Types
-----
->Single
->Multilevel
->Hierarcical

class Employee {
	int id = 100;
	String name = "Appu";

}

class Appu extends Employee {
	void display() {
		System.out.println("Name is: " + name);
		System.out.println("ID is: " + id);
	}

}

public class InheritanceDemo {

	public static void main(String[] args) {
		
		Appu a=new Appu();
		a.display();
		a.name="Shivu";
		a.display();

	}

}

OUTPUT:
Name is: Appu
ID is: 100
Name is: Shivu
ID is: 100

Static Instance Context Execution
---------------------------------
->JVM loads both Super and Sub class byte code to memory.
NOTE:Static context will be exe only once per class when object for the class is created, Instance context will be executed for each object creation.
First Super class then Subclass.


Super class Static var/block
Sub class Static var/block

Super class ins var/block
Super class const
Sub class ins var/block
Sub class const

Super class ins var/block
Super class const
Sub class ins var/block
Sub class const


Ex:
class A {

	A() {
		System.out.println("Super class Constructor");
	}

	static int a = m1();
	static {
		System.out.println("Super Class  SB");
	}

	static int m1() {
		System.out.println("Super Class SM");
		return 100;
	}

	int b = m2();
	{
		System.out.println("Super Class IB");
	}

	int m2() {
		System.out.println("Super Class IM");
		return 100;
	}
}

class B extends A {

	B() {
		System.out.println("Sub class Constructor");
	}

	static int x = p1();
	static {
		System.out.println("Sub Class SB");
	}

	static int p1() {
		System.out.println("Sub Class SM");
		return 100;
	}

	int b = p2();
	{
		System.out.println("Sub Class IB");
	}

	int p2() {
		System.out.println("Sub Class IM");
		return 100;
	}
}

public class StaticInstanceContextExeInInheritance {

	public static void main(String[] args) {

		B b1 = new B();
		System.out.println("**************************");
		B b2 = new B();

	}

}

OUTPUT:
Super Class SM
Super Class  SB
Sub Class SM
Sub Class SB
Super Class IM
Super Class IB
Super class Constructor
Sub Class IM
Sub Class IB
Sub class Constructor
**************************
Super Class IM
Super Class IB
Super class Constructor
Sub Class IM
Sub Class IB
Sub class Constructor
************************************************************************************************************************************************************
Day 80

SUPER KEYWORD
=============
->Super keyword is use to refer super class memebrs.[variables/methods/constructors]
->This keyword use to refer current class memebrs.[variables/methods/contructors/return current class obj ref]

To refer super class var/method/constructor 
------------------------
->super.variableName
->super.methodName()
->super([paramList]) / should be in first line of the constructor

->If parent and child relationship exist then child class super() should match with parent class constructor

Flow:super class constructor>child class constructor

parent()
{}
child()
{
super() //Works fine
}

parent(int 10)
{}
child()
{
super(); //ERROR , not matching with parent class const arg , Solution: use super(10)
}


->Var/Method preference [local>class>super class>object class]

Ex:
class Demo {
	int a = 20;
	public int i;

	void m1() {
		System.out.println("Super class M1");
	}

	Demo(int a) {
		System.out.println("Super class constructor");
	}
}

class Demo1 extends Demo {
	int a = 30;

	void m1() {
		int a = 100;
		super.i = 200;
		super.m1();
		System.out.println(a);
		System.out.println(this.a);
		System.out.println(super.a);
		System.out.println("Sub class M1");
	}

	Demo1() {
		super(22);
		System.out.println("Sub class constructor");
	}

}

public class SuperKeywordDemo {

	public static void main(String[] args) {

		Demo1 d = new Demo1();
		d.m1();
	}

}

OUTPUT:
Super class constructor
Sub class constructor
Super class M1
100
30
20
Sub class M1

************************************************************************************************************************************************************
Day 80

CLASS LEVEL TYPE CASTING[User defined]
======================================

Object for Sub Class/Ref var for Sub class
 All members of Sub and Super class

Object for Super Class/Ref var for Super class
 All members of Super class

Object for Sub Class/Ref var for Super class [Upcasting]
 All members of Super class, If any method is overrided then we get Sub class body for it.If we want body of Super class then use super.methodName()

Object for Super Class/Ref var for Sub class [Downcasting]
 Cant access any memebrs, it throws Classcast exception

->Type Casting:Convert data from one type to another type
->Type checking will be done by Compiler and JVM will does type casting [Assign RHS type to LHS and assign RHS var valu to LHS var].

Primitive
  Implicit:Lower to higher
  Explicit:Higher to lowe using cast operator

->User defined/Class level type casting
  Upcasting:Assign sub class ref value to Super class ref var
  Downcasting:Assign super class ref value to sub class ref var using cast opertor


Upcasting
---------
->Assign sub class ref value to Super class ref var.With this super class ref var we can access only super class methods. If we overrided super class method in sub class then we get sub class body not super class body[method overriding].
->Used to Method overriding


Ex:

class X {
	void m1() {
		System.out.println("Super M1");
	}

	void m2() {
		System.out.println("Super M2");
	}
}

class Y extends X {
	@Override
	void m1() {
		// super.m1();
		System.out.println("Sub M1");
	}

	void m3() {
		System.out.println("Sub M3");
	}
}

public class Upcasting {

	public static void main(String[] args) {

		X x1 = new X();
		x1.m1();
		x1.m2();
		System.out.println("*************************");

		X x2 = new Y(); // Upcasting
		x2.m1();
		x2.m2();

		System.out.println("*************************");
		Y y = new Y();
		y.m1();
		y.m2();
		y.m3();

	}

}

OUTPUT:
Super M1
Super M2
*************************
Sub M1
Super M2
*************************
Sub M1
Super M2
Sub M3

Downcasting
-----------
->Assign super class ref value to sub class ref var using cast opertor
->Cant able to access any members using this ref var it will throw Class cast exception

Ex:
class P {
	void m1() {
		System.out.println("Super M1");
	}

	void m2() {
		System.out.println("Super M2");
	}
}

class Q extends P {
	@Override
	void m1() {
		// super.m1();
		System.out.println("Sub M1");
	}

	void m3() {
		System.out.println("Sub M2");
	}
}

public class DowncastingDemo {

	public static void main(String[] args) {

		Q q = (Q) new P();
		q.m2();

	}

}

OUTPUT:
Exception in thread "main" java.lang.ClassCastException: class oops2.P cannot be cast to class oops2.Q (oops2.P and oops2.Q are in unnamed module of loader 'app')
	at oops2.DowncastingDemo.main(DowncastingDemo.java:29)

************************************************************************************************************************************************************
Day 84

POLYMORPHISM
============
->Types
	Static Polymorphism:Occurs at Compilation time Ex:Method overloading
	Dynamic Polymorphism:Occurs at runtime Ex:Method overriding

Method overloading
-------------------
->Two or more methods having same name but different parameter list [Parameter data type/Number of parameters/Parameters order]

Ex:
class MOD {
	int add(int a, int b) {
		return a + b;
	}

	int add(int a, int b, int c) {
		return a + b + c;
	}

	float add(float a, float b) {
		return a + b;
	}
	
	float add(int a, float b) {
		return a + b;
	}
	
	float add(float a, int b) {
		return a + b;
	}

}

public class MethodOverloadingDemo {

	public static void main(String[] args) {
		MOD m = new MOD();
		System.out.println(m.add(22.45f, 33.44f));
		System.out.println(m.add(11, 22));

	}

}


OUTPUT:
55.89
33

Method Overriding
-----------------
->Providing new functionality for the method avl in Super class in sub class.
->Procedure:
 Create method in Paarent class ex:dispaly()
 Give new functionality in child class for the same method.
 Create object for child class and reference var for parent class Ex:MethodOverriding m = new Child(); // METHOD OVERRIDING
 Call the method Ex:m.display()
   ->We get body of child class. Ex:Sub class

Ex:

class Parent {
	public void dispaly() {
		System.out.println("Super class");
	}
}

class Child extends Parent {
	@Override
	public void dispaly() {
		System.out.println("Sub class");
	}
}

public class MethodOverridingDemo {

	public static void main(String[] args) {
		Child c = new Child();
		c.dispaly(); //Sub class
		System.out.println("*******************");

		Parent p1 = new Parent();
		mo.dispaly(); //Super class
		System.out.println("*******************");

		Parent p2 = new Child(); // METHOD OVERRIDING
		m.dispaly(); //Sub class

		System.out.println("*******************");
	}

}

OUTPUT:
Sub class
*******************
Super class
*******************
Sub class
*******************

Rules and regulations
---------------------
->Sub class method return type should be same as super class method return type
->Sub class Access modifier should be same or greater than super class method [protected>default>public]
->Private methods cannot be overrided
->Final methods cannot be overrided, Super class method cannot be final, Sub class methods can be final.
->Static method cannot be overrided. If either super or sub or both  declared as static then method overriding is not possible.
  If super or sub is static then compiler will raise an error
  If both static we wont get compilation error but it will not be method overriding, it is method hiding. Super class hides su class method. We get output of super class method not sub class method.

Ex:
class Parent {
	public static void dispaly() {
		System.out.println("Super class");
	}
}

class Child extends Parent {
	// @Override
	public static void dispaly() {
		System.out.println("Sub class");
	}
}

public class MethodOverridingDemo {

	public static void main(String[] args) {
		Parent p = new Child();
		p.dispaly(); //Super class

	}

}

************************************************************************************************************************************************************
Day 85

Abstract Method
----------------
->Method without body with keyword abstarct
->Abstract method should be in Abstract class 

ABSTRACT CLASS
==============
->Class contains 0 to N abstract/concrete methods
->Class with keyword abstarct
->Cannot create object, can create only ref var
->Implementation class should provide body for all the methods else that clas will also be abstract.We can create obj only for comple class.
->Can contain constructor
->One abstract class can extend other abstract class
->One abstract class can extend other normal class
->One abstract class can provide body for abstract method of another abstarct class, if that done then no need of imp class to provide body again.Imp class will be used only for creating object.
->Constructor is needed for Ac to execute instance context

Ex:
abstract class Abstract1 {
	abstract void m1();

	public Abstract1() {
		System.out.println("Abstract1 Constructor");
	}

	void m2() {
		System.out.println("Abstract1 M2");
	}
}

class ImplementationClass extends Abstract1 {

	@Override
	void m1() {
		System.out.println("Abstract Implement M1");
	}

	void m3() {
		System.out.println("ImplementationClass M3");
	}

}

public class AbstractClass {

	public static void main(String[] args) {

		Abstract1 a1 = new ImplementationClass();
		a1.m1();
		a1.m2();

		System.out.println("******************8");
		Abstract1 a2 = new ImplementationClass();
		a2.m1();
		a2.m2();

	}

}

OUTPUT:
Abstract1 Constructor
Abstract Implement M1
Abstract1 M2
******************8
Abstract1 Constructor
Abstract Implement M1
Abstract1 M2

->One abstract class can provide body for abstract method of another abstarct class, if that done then no need of imp class to provide body again.

Ex:Abstract2 class providing body to Abstract1 class method.

package oops2;

abstract class Abstract1 {
	abstract void m1();

	public Abstract1() {
		System.out.println("Abstract1 Constructor");
	}

	void m2() {
		System.out.println("Abstract1 M2");
	}
}

abstract class Abstract2 extends Abstract1 {
	@Override
	void m1() {
		System.out.println("Abstract Implement M1");
	}
}

class ImplementationClass extends Abstract2 {
	void m3() {
		System.out.println("ImplementationClass M3");
	}

}

public class AbstractClass {

	public static void main(String[] args) {

		Abstract1 a1 = new ImplementationClass();
		a1.m1();
		a1.m2();

		System.out.println("******************8");
		Abstract1 a2 = new ImplementationClass();
		a2.m1();
		a2.m2();

	}

}

OUTPUT:
Abstract1 Constructor
Abstract Implement M1
Abstract1 M2
******************8
Abstract1 Constructor
Abstract Implement M1
Abstract1 M2

************************************************************************************************************************************************************
Day 94

WRAPPER CLASS
=============
->Collection is an object used to store group of other objects, to store primitive data into collection it has to be converted to object type with help of Wrapper class.

Primitive data->[Wrapper class]->Object type->Store in Collection->Fetch Object type data from COllection->Covert to Primitive type->Use Prmitive data

Primitive type->Object Type                                Object type->Primitive type
 int i=10->Integer in=10        ->Store in in Collection->   Integer in=10->int i=10

->Wrapper class objects are Immutable objects

Ex:java.lang.Integer
To convert int to Integer

Conversion
-----------
->Primitive to Object 
int i=10;
Ineteger in=i;

->Object to Primitive
Integer in=new Ineteger(10);
int i=in;

->String to Object
String st="10";
Integer in=Integer.valueOf(st);

->Object to String
Integer in=new Ineteger(10);
String st=in.toString(); OR
String st=in+"";

->Primitive to String
int i=10;
String st=Integer.toString(i); OR
String st=i+" ";

->String to Primitive
String st=10;
int i=Integer.parseInt(i);

************************************************************************************************************************************************************
Day 95

PACKAGES
========
->Collection of related classes and interfaces as single unit
->Folder contains .class files representing related classes and interfaces.

Ex:java.lang/java.util....

->package name format
companyDomainNameInReverse.projectName.moduleName.subModuleName;
com.ibm.ivr.facilityinquiry


->To import package
import java.util.*;
import java.util.ArrayList;

Makes available the package to present java file, compiler checks is that package exist in java software, jvm loads to memory needed classes and interfaces.

->Fully Qualified Name:
packagename.membername
Ex:java.util.ArrayList list=new java.util.ArrayList(); //No need to import the java.util package 

************************************************************************************************************************************************************
INTERFACES
==========
->All methods are by default public abstract
->Contains only Abstract methods
->All varibales are by default are public static final, can be access using Interface name, Class name, Reference variable
->Implementation class should implement interface and provide method to all the body else that class should be abstract
->Overriding method acess specifier should be public
->One class can implements any number of interfaces, no dimension problem
->Object cannot be created
->One interface can extend another interface but cannot implements another interface
->One class can extend one class and implements 0 to N interfaces.
->Without using implement keyword also we can implement the interface


Ex:
interface Calculator {
	void add();

}

class Casio implements Calculator {

	@Override
	public void add() {
		int a = 10, b = 20;
		int c = a + b;
		System.out.println(c);
	}

}

class Ajantha implements Calculator {

	@Override
	public void add() {
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter a and b value");
		int a = sc.nextInt();
		int b = sc.nextInt();
		int c = a + b;
		System.out.println(c);
	}

}

public class InterfaceDemo3 {

	public static void main(String[] args) {

		Calculator c1 = new Casio();
		c1.add();

		Calculator c2 = new Ajantha();
		c2.add();

	}

}

Java 8
->Interface can have one method with body that is default method.
->Implementing class is not mandatory to provide implementation for default method, if needed it can be overridden

Ex:Default method in Interface
interface Calculator1 {
	void add();

	default void display() {
		System.out.println("Default method");
	}

}

class Casio1 implements Calculator1 {

	@Override
	public void add() {
		int a = 10, b = 20;
		int c = a + b;
		System.out.println(c);
	}

}

public class InterfaceDemo4 {

	public static void main(String[] args) {

		Calculator1 c = new Casio1();
		c.display();

	}

}

Ex: Overridning default method
interface Calculator1 {
	void add();

	default void display() {
		System.out.println("Default method");
	}

}

class Casio1 implements Calculator1 {

	@Override
	public void add() {
		int a = 10, b = 20;
		int c = a + b;
		System.out.println(c);
	}

	@Override
	public void display() {
		System.out.println("Default method of child class");
	}

}

public class InterfaceDemo4 {

	public static void main(String[] args) {

		Calculator1 c = new Casio1();
		c.display();

	}

}

Java 8
->Interface can have static method with body and cannot be overrided in imp class

Ex:Static method with body in interface

interface Calculator1 {
	void add();

	default void display() {
		System.out.println("Default method");
	}
	
	static void staticMethod()
	{
		System.out.println("Static method in Interface");
	}

}

class Casio1 implements Calculator1 {

	@Override
	public void add() {
		int a = 10, b = 20;
		int c = a + b;
		System.out.println(c);
	}

	@Override
	public void display() {
		System.out.println("Default method of child class");
	}
	

}

public class InterfaceDemo4 {

	public static void main(String[] args) {

		Calculator1 c = new Casio1();
		c.display();
		
		Calculator1.staticMethod();

	}

}


Java 8
Implementing Interface
----------------------

Inner class
-----------
 Memebr Inner class
 Static Inner class
 Anonymous Inner class

Ex:Memebr Inner class
class A {
	int a = 10;

	void show() {
		System.out.println("In A Show");
	}

	class B {
		void show() {
			System.out.println("In B Show");
		}
	}
}

public class InnerClassDemo {

	public static void main(String[] args) {

		A a = new A();
		a.show();

		A.B b = a.new B();
		b.show();
	}

}

Ex:Static Inner class

class C {
	void show() {
		System.out.println("C class show");
	}

	static class D {
		void show() {
			System.out.println("D class show");
		}
	}
}

public class StaticInnerClass {

	public static void main(String[] args) {
		C.D c = new C.D();
		c.show();

	}

}


Anonymous Inner class
---------------------
->Class with no name
->Any number of anonuous inner class can be created 
->Used to override normal method, provide imp for Interface and Abstract class

Syntax:
className/interfaceName/abstractclassName refVar=new className()/interfaceName()/abstractclassName(){override method};
refVar.overridedMethod();

Ex 1:Anonymous inner class for overriding class method
class Car {
	void driving() {
		System.out.println("Driving");
	}
}

public class AnonymousInnerClass1 {

	public static void main(String[] args) {

		Car c = new Car() {

			@Override
			void driving() {
				System.out.println("NFS Driving");
			}
		};

		c.driving();

	}

}

Ex 2:Any number of Inner class can be created
class Car {
	void driving() {
		System.out.println("Driving");
	}
}

public class AnonymousInnerClass1 {

	public static void main(String[] args) {

		Car c = new Car() {

			@Override
			void driving() {
				System.out.println("NFS Driving");
			}
		};

		c.driving();
		
		Car d = new Car() {

			@Override
			void driving() {
				System.out.println("Sanaddress car Driving");
			}
		};
		d.driving();

	}

}

Ex 3:Anonymous IC for Interface implementtion

interface I {
	void add();
}

public class AnonymousInnerclassForInterface {

	public static void main(String[] args) {

		I i1 = new I() {

			@Override
			public void add() {
				int a = 10, b = 20;
				System.out.println(a + b);

			}

		};
		
		i1.add();

	}

}

Ex 4:Anonymous IC for Abstract class Implementation
abstract class Abstract {
	abstract void add();

	public Abstract() {
		System.out.println("Abstract Constructor");
	}
}

public class AnonymousInnerclassForAbstractClass {

	public static void main(String[] args) {

		Abstract a = new Abstract() {

			@Override
			void add() {
				int a = 10, b = 20;
				System.out.println(a + b);

			}
		};

		a.add();

	}

}

OUTPUT:
Abstract Constructor
30

Converting Abbstract class to lambda exp

Ex:Lambda Exp/Converting Abbstract class to lambda exp

interface P {
	void display();
}

public class AbstractClassToLambdaExp1 {

	public static void main(String[] args) {

		P p = () ->System.out.println("Lambda");

		p.display();

	}

}

************************************************************************************************************************************************************
IS A-Abstract class
Behaviour-Interface
************************************************************************************************************************************************************
ARRAYS
======
->Object used to store group of homogeneous data in heap area.
->Index based DS

Declaration of Array:
int a[]=new int[4];
int a[]={1,2,3};
int a[]=new int[]{1,2,3};

Ex: 1 D Array
public class SingleDimArrayDemo {

	public static void main(String[] args) {
		int a[] = new int[5];
		a[0] = 10;
		a[1] = 20;
		a[2] = 30;
		// a[3] = 40;
		a[4] = 50;

		for (int i : a) {
			System.out.print(i + " ");
		}

		System.out.println();

		int b[] = { 1, 2, 3, 4, 5 };

		for (int i : b) {
			System.out.print(i + " ");
		}
	}

}

OUTPUT:
10 20 30 0 50 
1 2 3 4 5 

Ex:To store Object type data
class Student {
	public void display() {
		System.out.println("Display method");
	}
}

public class ArrayToStoreObjectTypeData {

	public static void main(String[] args) {

		Student s1 = new Student();
		Student s2 = new Student();
		Student s3 = new Student();

		Student st[] = new Student[3];
		st[0] = s1;
		st[1] = s2;
		st[2] = s3;

		for (Student s : st) {
			System.out.println(s);
			s.display();

		}

	}

}

OUTPUT:
telusko.Student@5d22bbb7
Display method
telusko.Student@123772c4
Display method
telusko.Student@2d363fb3
Display method


2D Array
--------
Ex:
public class TwoDimArray {

	public static void main(String[] args) {

		int a[][] = new int[2][3];

		a[0][0] = 10;
		a[0][1] = 10;
		a[0][2] = 10;

		a[1][0] = 10;
		a[1][1] = 10;
		a[1][2] = 10;

		for (int i = 0; i < a.length; i++) {
			for (int j = 0; j < a[i].length; j++) {
				System.out.print(a[i][j] + " ");
			}
			System.out.println();
		}

	}

}

OUTPUT:
10 10 10 
10 10 10 

Ex:Jagged Array


public class JaggedArrayDemo {

	public static void main(String[] args) {

		int a[][] = new int[3][];
		a[0] = new int[2];
		a[1] = new int[3];
		a[2] = new int[4];

		a[0][0] = 10;
		a[0][1] = 20;

		a[1][0] = 30;
		a[1][1] = 40;
		a[1][2] = 50;

		a[2][0] = 30;
		a[2][1] = 40;
		a[2][2] = 50;
		a[2][3] = 50;

		for (int[] i : a) {
			for (int j : i) {
				System.out.print(j + " ");
			}
			System.out.println();
		}

	}

}

OUTPUT:
10 20 
30 40 50 
30 40 50 50 

Ex:EMployee Array
class Employee {
	String name;
	int age;

	void display() {
		System.out.println(name + " age is:" + age);
	}
}

public class StudentArrayDemo {

	public static void main(String[] args) {

		Employee e[] = new Employee[3];
		e[0] = new Employee();
		e[1] = new Employee();
		e[2] = new Employee();

		e[0].age = 10;
		e[0].name = "Appu";
		e[0].display();

		e[1].age = 20;
		e[1].name = "Shivu";
		e[1].display();

		e[2].age = 30;
		e[2].name = "Raghu";
		e[2].display();

	}

}


OUTPUT:
Appu age is:10
Shivu age is:20
Raghu age is:30

->Arrays class is used to perofrm operation on Arrays
************************************************************************************************************************************************************
STRINGS
=======
->Anything inside "" is considered as String object
->Whever we create String object, one copy will be in SCP
->If used new then create in heap else create in SCP
->SCP not allow duplicate, Heap allow duplicate
->Reference variable stored in stack memory

Types:
 Mutable:Changable Ex:StringBuffer/StrinBuilder/Data inside the memory can be updated
 Immutable:Non changable Ex:String/Data inside the memory cannot be changed


String
------
Heap:Duplicte allowed/Eligible for GC
SCP:Inside Heap/No duplicates/Not eligible for GC

Case 1:

Ex1:
String str1="Appu"; //Created in SCP
String str1="Appu"; //Created in SCP
both str1 and str2 refers to same object since already existed, no duplicates allowed.

str1--->
             Appu
str2---> 

str1==str2 //true both will be having same reference value,points to same object
str1.equals(str2) //true

Ex2:
String str1="Appu1"; //Created in SCP
String str1="Appu2"; //Created in SCP
str1 and str2 refers to different objects

str1--->     Appu1
str2--->     Appu2

str1==str2 //false both will refer different object, reference value will be different
str1.equals(str2) //false

Case 2:
String str1=new String("Raghu"); //Created in SCP and Heap
String str2=new String("Raghu"); //Created in SCP and Heap
both str1 and str2 refers to different object, duplicates allowed.

str1-->Raghu [Heap]
str2-->Raghu [heap]

str1--->
         Raghu [SCP]
str2--->

str1==str2 //false, both refer to doff fobject and will be having diff ref value
str1.equals(str2) //true

Ex:

public class StringDemo1 {

	public static void main(String[] args) {

		String str1 = "Appu";
		String str2 = "Appu";

		System.out.println(str1.equals(str2));
		System.out.println(str1 == str2);

		System.out.println("********************88");

		String s1 = new String("Raghu");
		String s2 = new String("Raghu");

		System.out.println(s1.equals(s2));
		System.out.println(s1 == s2);

	}

}


OUTPUT:
true
true
********************
true
false

compareTo()
----------
->Dict order comparision
->0:equal pos:str1>str2 neg:str2>str1
->Ascii value comparision

String s1="appu"
String s2="appu"
s1.compareTo(s2) //0 Since both are equal

concat()
--------
Ex:
public class StringDemo1 {

	public static void main(String[] args) {

		String str1 = "Appu";
		System.out.println(str1);
		System.out.println("********************");

		str1.concat("Rajkumar");
		System.out.println(str1);
		System.out.println("********************");

		String str2 = str1.concat("rajkuamr");
		System.out.println(str1);
		System.out.println(str2);
		System.out.println("********************");

		String s1 = "Raghu";
		s1 = s1.concat("Rajkumar");
		System.out.println(s1);
		System.out.println("********************");

	}

}

OUTPUT:
Appu
********************
Appu
********************
Appu
Appurajkuamr
********************
RaghuRajkumar
********************

Concatenation operator +
------------------------
String str="Appu"+"Rajkuamr"

Other methods
-------------
public class StringDemo1 {

	public static void main(String[] args) {
                String str1 = " Appu Rajkumar ";
		System.out.println(str1.charAt(2));
		System.out.println(str1.substring(3));
		System.out.println(str1.stripLeading());
		System.out.println(str1.stripTrailing());
		System.out.println(str1.split(" "));
		System.out.println(str1.indexOf("p"));
                System.out.println(str1.length());

	}

}


OUTPUT:
p
pu Rajkumar 
Appu Rajkumar 
 Appu Rajkumar
[Ljava.lang.String;@71dac704
2
15

STRING BUFFER
-------------
->Mutable string, allow modification on its content

Ex:
public class StringBufferDemo {

	public static void main(String[] args) {
		
		StringBuffer sb=new StringBuffer("Appu");
		System.out.println(sb);
		sb.append("Rajkuamr");
		System.out.println(sb);

	}

}

OUTPUT:
Appu
AppuRajkuamr

->
StringBuffer sb1=new StringBuffer("Appu Rajkumar");
StringBuffer sb2=new StringBuffer("Appu Rajkumar");
System.out.println(sb1.equals(sb2)); //false

Used to do ref value comparision not content comparision

->final keyword will not affect mutability feature of string buffer

public class StringBufferDemo {

	public static void main(String[] args) {

		final StringBuffer sb1 = new StringBuffer("Appu");
		System.out.println(sb1);
		sb1.append("Rajkuamr");
		System.out.println(sb1);

	}

}

OUTPUT:
Appu
AppuRajkuamr

StringBuffer VS StringBuilder
------------------------------
StringBuffer:Not supports multithreading[Synchronized methods]
StringBuilder:Supports multithreading

************************************************************************************************************************************************************
LABMDA EXPRESSION
=================

->Interface Types
 Normal:Interface with more than one abstract methods
 SAM[Functional Interface]:Interface with single abstract method
 Marker:Interface with zero method
->Reduce n of lines, not create seperate class files
->Lambda exp works only for SAM/Functional interafce




Ex 1:Anonymous IC to Lambda for Interface

interface Bike {
	void ride();
}

public class LambdaExpression1 {

	public static void main(String[] args) {

		Bike obj = new Bike() {
			@Override
			public void ride() {
				System.out.println("riding");
			}
		};
		obj.ride();

	}

}

interface Bike {
	void ride();
}

public class LambdaExpression1 {

	public static void main(String[] args) {
		Bike obj = () -> System.out.println("riding");

		obj.ride();

	}

}

Ex 2:
interface I1 {
	void add(int a, int b);
}

public class LambdaExp2 {

	public static void main(String[] args) {

		I1 i = new I1() {
			@Override
			public void add(int a, int b) {
				System.out.println(a + b);
			}
		};

		i.add(10, 20);

	}

}

interface I1 {
	void add(int a, int b);
}

public class LambdaExp2 {

	public static void main(String[] args) {

		I1 i = (a, b) -> System.out.println(a + b);
		i.add(10, 20);

	}

}


Ex 3:
interface Lambda {
	float add(int a, float b);
}

public class LambdaExp3 {

	public static void main(String[] args) {

		Lambda l = new Lambda() {
			@Override
			public float add(int a, float b) {
				float c = 0;
				c = a + b;
				return c;
			}
		};

		float res=l.add(10, 20.44f);
		System.out.println(res);

	}

}

interface Lambda {
	float add(int a, float b);
}

public class LambdaExp3 {

	public static void main(String[] args) {
		Lambda l = (a, b) -> {
			float c = 0;
			c = a + b;
			return c;

		};

		float res = l.add(10, 20.44f);
		System.out.println(res);

	}

}

Ex 4:
interface Lambda4 {
	int add(int a);
}

public class LambdaExp4 {

	public static void main(String[] args) {

		Lambda4 l = new Lambda4() {

			@Override
			public int add(int a) {
				return a * a;
			}
		};
		System.out.println(l.add(20));
	}

}

interface Lambda4 {
	int add(int a);
}

public class LambdaExp4 {

	public static void main(String[] args) {
		Lambda4 l = a -> a * a;
		System.out.println(l.add(20));
	}

}

Ex 5:
->RHS part of lambda exp is just an object which looks like function, it can be passed as an argument.

Ex:
interface Lambda4 {
	int add(int a);

	public static void lambdaAsparameter(Lambda4 l) {

	}
}

public class LambdaExp4 {

	public static void main(String[] args) {
		Lambda4 l = a -> a * a;
		System.out.println(l.add(20));

		Lambda4.lambdaAsparameter(l);
		Lambda4.lambdaAsparameter(a -> a * a);
	}

}
************************************************************************************************************************************************************
Default Method in Interface
---------------------------
->Method with keyword defualt and with body inside the interface
->Can be overrided[optional]

FOREACH Method for COllection
-----------------------------
Ex:

public class ForEachForCollection {

	public static void main(String[] args) {

		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(10);
		list.add(20);
		list.add(30);

		list.forEach(n -> System.out.println(n));
		list.forEach(n -> System.out.println(n * n));

	}

}

************************************************************************************************************************************************************
EXCEPTION HANDLING
==================

.java->Compiler->.class->JVM->RAM[JRE]CPU->Output
  Comilation Phase              Execution phase

Error:Programming mistake by developer at compilation time/runtime which cant be handled through programming.[Syntax/Semantic..errors]

Exception
---------
->Abnormal condition that may leads to abnormal termination[abrupt] of the program, can be handled by programming.
->Occurs at runtime , can be identified at compilation time or at runtime.
        
Ex:Facebook not responding

Ex 1:Program without exception handling can leads to abrubt termination
public class ProgramwithoutExceptionhandling {

	public static void main(String[] args) {

		System.out.println("START");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter numerator");
		int a = sc.nextInt();
		System.out.println("Enter denominator");
		int b = sc.nextInt();
		int res = a / b; //Exception causing statement
		System.out.println("Result is: " + res);
		System.out.println("STOP");

	}

}

OUTPUT:
START
Enter numerator
100
Enter denominator
0
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.ProgramwithoutExceptionhandling.main(ProgramwithoutExceptionhandling.java:15)

Case 1:Exp occurs/No User def exp handling
Prog exe>Exception occurs>Control go to JVM>JVM checks user def exception handler>If not, control goes to default exp handler present in JVM>Print details of exception[name/description/exp causing statment location]>Abnormal termination of program[Lines below the exp causing statemet will not be executed]

Case 2:Exp occurs/User def exp handling
Prog exe>Exception occurs>Control go to JVM>JVM checks user def exception handler>Control moves to default exp handler[catch block]>Execute code of catch block>Smooth termination of program[Lines below the exp causing statemet will be executed after catch block]

Handling Exception
------------------

->Identify exp causing statement only
->Put in to try block
->If exception occurs in catch block then it will go to default exp handler and leads to abnormal termination

Ex:Program with exception handling can leads to smooth termination
public class ProgramwithoutExceptionhandling {

	public static void main(String[] args) {

		System.out.println("START");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter numerator");
		int a = sc.nextInt();
		System.out.println("Enter denominator");
		int b = sc.nextInt();
		int res = 0;
		try {
			res = a / b; // Exception causing statement
			System.out.println("Result is: " + res); //If exp occurs in prev line, this statement will not be executed.
		} catch (Exception e) {
			System.out.println("You have entered 0 as denominator, Pls check the input and try again");
			e.printStackTrace();
		}

		System.out.println("STOP");

	}

}

OUTPUT:
START
Enter numerator
100
Enter denominator
0
java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.ProgramwithoutExceptionhandling.main(ProgramwithoutExceptionhandling.java:17)
Result is: 0
STOP

->If exp occurs, lines below try block will not be executed.Only statement after catch block will be executed.


Multiple Catch Block
--------------------
->One try can have 0[need finally] to N catch block
->Always provide different catch block for different exception
->At end provide one generic catch block
->If there exist relation between the catch block exception then first must be child then parent.
catch(parent)
catch(child) //error

catch(child)
catch(parent) //works fine
->Seperate try catch for seperate exception causing statements.


Ex3:Exception while adding element to array with multiple catch block
public class ExceptionWhileEnteringElementIntoArray {

	public static void main(String[] args) {

		System.out.println("START");
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter Array size");
		int size = sc.nextInt();
		int a[] = new int[size];

		System.out.println("Enter element");
		int ele = sc.nextInt();
		System.out.println("Enter position");
		int pos = sc.nextInt();

		a[pos] = ele; //Exception causing statement

		for (int i : a) {
			System.out.print(i + " ");
		}
		System.out.println();
		System.out.println("STOP");

	}

}

OUTPUT:
START
Enter Array size
5
Enter element
222
Enter position
222
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 222 out of bounds for length 5
	at exceptionhandlingtelusko.ExceptionWhileEnteringElementIntoArray.main(ExceptionWhileEnteringElementIntoArray.java:21)

Solution:
public class ExceptionWhileEnteringElementIntoArray {

	public static void main(String[] args) {

		System.out.println("START");
		Scanner sc = new Scanner(System.in);

		System.out.println("Enter Array size");
		int size = sc.nextInt();
		int a[] = new int[size];

		System.out.println("Enter element");
		int ele = sc.nextInt();
		System.out.println("Enter position");
		int pos = sc.nextInt();

		try {
			a[pos] = ele; // Exception causing statement

			for (int i : a) {
				System.out.print(i + " ");
			}
		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("Index value is out of limit");
			e.printStackTrace();
		} catch (NegativeArraySizeException e) {
			System.out.println("Index value is negative");
			e.printStackTrace();
		} catch (Exception e) {
			System.out.println("Generic exception");
			e.printStackTrace();
		}

		System.out.println();
		System.out.println("STOP");

	}

}

OUTPUT:
START
Enter Array size
5
Enter element
33
Enter position
5
Index value is out of limit
java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5
	at exceptionhandlingtelusko.ExceptionWhileEnteringElementIntoArray.main(ExceptionWhileEnteringElementIntoArray.java:22)

STOP

Ex 4:Multiple catch block
public class ExceptionWhileEnteringElementIntoArray {

	public static void main(String[] args) {

		System.out.println("START");

		try {
			Scanner sc = new Scanner(System.in);

			System.out.println("Enter Array size");
			int size = sc.nextInt();
			int a[] = new int[size];

			System.out.println("Enter element");
			int ele = sc.nextInt();
			System.out.println("Enter position");
			int pos = sc.nextInt();

			System.out.println("***DIVISION*****");
			int res = ele / pos; // Exception causing statement
			System.out.println("Result is:" + res);
			System.out.println("***DIVISION*****");

			System.out.println("***ARRAY*****");
			a[pos] = ele; // Exception causing statement

			for (int i : a) {
				System.out.print(i + " ");
			}
			System.out.println("***ARRAY*****");

		} catch (ArrayIndexOutOfBoundsException e) {
			System.out.println("Index value is out of limit");
			e.printStackTrace();
		} catch (NegativeArraySizeException e) {
			System.out.println("Index value is negative");
			e.printStackTrace();
		} catch (ArithmeticException e) {
			System.out.println("Denominator is 0");
			e.printStackTrace();
		}

		catch (Exception e) {
			System.out.println("Generic exception");
			e.printStackTrace();
		}

		System.out.println();
		System.out.println("STOP");

	}

}

OUTPUT:
START
Enter Array size
5
Enter element
100
Enter position
0
***DIVISION*****
Denominator is 0
java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.ExceptionWhileEnteringElementIntoArray.main(ExceptionWhileEnteringElementIntoArray.java:24)

STOP

Ex 5:Exception occuring in calling function/called function
->Always try to handle exception in calling function[where exaclty exp occurs]
->JVM search for present method, else go to calling method else go to def exp handler
->In below prog, try to handle in alpha() since exp occurin at that method itself.

->Not handled in both calling and called function-Abrupt termination in both Called and calling function
->Here exp is not handled by both calling and called function so it will go to JVM def exp handler
class Sample {
	static void alpha(int a, int b) {
		
		System.out.println("ALPHA START");
		int res = a / b;
		System.out.println("Res is: " + res);
		System.out.println("ALPHA END");
	}
}

public class ExceptionOccursInCallingcalledFucntion {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		Sample.alpha(100, 0);
		System.out.println("MAIN END");

	}

}

OUTPUT:
MAIN START
ALPHA START
Exception in thread "main" java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.Sample.alpha(ExceptionOccursInCallingcalledFucntion.java:9)
	at exceptionhandlingtelusko.ExceptionOccursInCallingcalledFucntion.main(ExceptionOccursInCallingcalledFucntion.java:20)


->Handled in Called function-Abrupt termination in Calling function
class Sample {
	static void alpha(int a, int b) {

		System.out.println("ALPHA START");
		int res = a / b;
		System.out.println("Res is: " + res);
		System.out.println("ALPHA END");
	}
}

public class ExceptionOccursInCallingcalledFucntion {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		try {
			Sample.alpha(100, 0);
		} catch (Exception e) {
			System.out.println("Invalid input");
			e.printStackTrace();
		}

		System.out.println("MAIN END");

	}

}

OUTPUT:
MAIN START
ALPHA START
Invalid input
java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.Sample.alpha(ExceptionOccursInCallingcalledFucntion.java:9)
	at exceptionhandlingtelusko.ExceptionOccursInCallingcalledFucntion.main(ExceptionOccursInCallingcalledFucntion.java:21)
MAIN END


->Handled in Calling function-Smooth termination
class Sample {
	static void alpha(int a, int b) {

		System.out.println("ALPHA START");
		try {
			int res = a / b;
			System.out.println("Res is: " + res);
		} catch (Exception e) {
			System.out.println("Invalid input");
			e.printStackTrace();
		}

		System.out.println("ALPHA END");
	}
}

public class ExceptionOccursInCallingcalledFucntion {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		Sample.alpha(100, 0);
		System.out.println("MAIN END");

	}

}


OUTPUT:
MAIN START
ALPHA START
Invalid input
java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.Sample.alpha(ExceptionOccursInCallingcalledFucntion.java:10)
	at exceptionhandlingtelusko.ExceptionOccursInCallingcalledFucntion.main(ExceptionOccursInCallingcalledFucntion.java:26)
ALPHA END
MAIN END

Exception Object
----------------
->Exception object contains
e.printStacktrace() //Name,Description,Location[Stacktrace,Calling and called method location]
e.getMessage() //Description
e.toString() //Name and Description

Exception generation
--------------------
->Can handle using try catch
->Ducking[By Pass] exception/throw the exception from calling to called function[throws]
->Rethrowing exception[throw/throws/try catch finally]

Exception Types
---------------
Checked
 Identified by Compiler Ex:IntruptedException, Filenotfound Exception
UnChecked 
 Identified by JVM at runtime

throws
-------
->Used to bypass the exception
->Used to throw exception from called function to calling function or to JVM

throw
-----
->Used to throw the exception
->Below thorw keyword cant able to write any stattements

Ex:Handling exception and throwing it to called method
Alpha handles exception and also throw to main emthod to handle there also

->Only handle and but not thow
class HandleAndThrow {
	
	static void alpha(int a, int b) {

		System.out.println("ALPHA START");
		try {
			int res = a / b;
			System.out.println("Res is: " + res);
		} catch (Exception e) {
			System.out.println("Invalid input");
			e.printStackTrace();
		}

		System.out.println("ALPHA END");
	}
}

public class HandleAndThrowExceptionDemo {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		Sample.alpha(100, 0);
		System.out.println("MAIN END");

	}

}

OUTPUT:
MAIN START
ALPHA START
Invalid input
java.lang.ArithmeticException: / by zero
	at exceptionhandlingtelusko.Sample.alpha(ExceptionOccursInCallingcalledFucntion.java:10)
	at exceptionhandlingtelusko.HandleAndThrowExceptionDemo.main(HandleAndThrowExceptionDemo.java:25)
ALPHA END
MAIN END


->Handle in Alpha method, Throw to Main method, Handle in main method
class HandleAndThrow {

	static void alpha(int a, int b) throws Exception {

		System.out.println("ALPHA START");
		try {
			int res = a / b;
			System.out.println("Res is: " + res);
		} catch (Exception e) {

			System.out.println("Invalid input");
			System.out.println("Handle in Alpha method and throw to main method");
			throw e;

		}

		System.out.println("ALPHA END");
	}
}

public class HandleAndThrowExceptionDemo {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		try {
			HandleAndThrow.alpha(100, 0);
		} catch (Exception e) {
			System.out.println("Handle in Main method also");
		}
		System.out.println("MAIN END");

	}

}

OUTPUT:
MAIN START
ALPHA START
Invalid input
Handle in Alpha method and throw to main method
Handle in Main method also
MAIN END

Note:ALPHA END is not exe since control move from alpha to finally so add that statement in finally block

finally
-------
->If any stm has to be exe whether exc occur or not then add those statement in finally block
->exp occur or not /catch handles or not/even in catch exp occur or not-finally block will be executed[without finally execution control not terminates
->To clean up code
->Once we add finally, without executing finally control will never terminate
->System.exit(0) dominates finally block

try catch finally // allowed
try finally // allowed
try finally catch //not allowed

try
{
s1
s2 //Exception causing stm
s3
s4
}

catch
{
s5
s6
}

Exception:
s1 s2 s5 s6 but s3 and s4 not exe, so if we need to exe those stm even if exp occurs then add it to finally block

try
{
s1
s2 //Exception causing stm
}

catch
{
s5
s6
}

finally
{
s3
s4
}

Ex:
public class FinallyDemo {

	public static void main(String[] args) {

		try {
			System.out.println("Statement 1");
			System.out.println("Statement 2");
			throw new ArithmeticException();

		}

		catch (Exception e) {
			System.out.println("Catch block code");
		} finally {
			System.out.println("Statement 4");
			System.out.println("Statement 5");
		}

	}

}

OUTPUT:
Statement 1
Statement 2
Catch block code
Statement 4
Statement 5


Ex:

class HandleAndThrow {

	static void alpha(int a, int b) throws Exception {

		System.out.println("ALPHA START");
		try {
			int res = a / b;
			System.out.println("Res is: " + res);
		} catch (Exception e) {

			System.out.println("Invalid input");
			System.out.println("Handle in Alpha method and throw to main method");
			throw e;

		}

		finally {
			System.out.println("ALPHA END");
		}

	}
}

public class HandleAndThrowExceptionDemo {

	public static void main(String[] args) {

		System.out.println("MAIN START");
		try {
			HandleAndThrow.alpha(100, 0);
		} catch (Exception e) {
			System.out.println("Handle in Main method also");
		}
		System.out.println("MAIN END");

	}

}


OUTPUT:
MAIN START
ALPHA START
Invalid input
Handle in Alpha method and throw to main method
ALPHA END
Handle in Main method also
MAIN END

->finally vs return
fnally will be dominated than return, even there is return statement finally will be executed

Ex:
class Temp {
	static int add(int a, int b) {
		try {
			return a + b;
		} finally {
			return 100;
		}

	}
}

public class FinallyVSReturn {

	public static void main(String[] args) {
		
		System.out.println(Temp.add(10, 10));
	}

}

OUTPUT:
100

Exception Hierarchy
-------------------
Object->Throwable->Error/Exception

Error
 VirtualMachineError
   OutOfMemoryError
   StackOverflowError
 LinkageError
 AssertionError

Exception
 RuntimeException
    ArithemeticException
    NullpointerException
    ClassCastException
    IndexOutOfBoundException
      ArrayIndexOutOfBoundException
      StringIndexOutOfBoundException
    IOException
      EOFException
      FileNotFoundException
    IntruptedException
    SQLException


Custom Exception
----------------
->Any class which is extending Exception class is exception class

class anyExceptionClass extends Exception
{
  public anyExceptionClass(String str)
   {
    supper(str);
   }
}

throw new anyExceptionClass("Something went wrong");

Ex:

class SometinWentWrongException extends Exception {
	public SometinWentWrongException(String str) {
		super(str);
	}
}

public class CustomExceptionDemo1 {

	public static void main(String[] args)throws SometinWentWrongException {
		
		Scanner sc=new Scanner(System.in);
		System.out.println("Enter age");
		int age=sc.nextInt();
		
		if(age<18)
		{
			throw new SometinWentWrongException("Age s less than 18 eror");
		}
		else
		{
			System.out.println("You are eligible to vote");
		}
	}

}

OUTPUT:
Enter age
11
Exception in thread "main" exceptionhandlingtelusko.SometinWentWrongException: Age s less than 18 eror
	at exceptionhandlingtelusko.CustomExceptionDemo1.main(CustomExceptionDemo1.java:21)


Ex:

class InvalidCredException extends Exception {
	public InvalidCredException(String str) {
		super(str);
	}
}

class LoginPage {
	String acctName = "Appu";
	String password = "Appu123";
	String an, pw;
	Scanner sc = new Scanner(System.in);

	public void getInput() {
		System.out.println("Enter name");
		an = sc.next();
		System.out.println("Enter password");
		pw = sc.next();
	}

	public void verify() throws InvalidCredException {
		int i = 0;
		if (an.equals(acctName) && pw.equals(password)) {
			System.out.println("Successfull Login");
		} else {
			// i++;
			// int remainingAttempt = 3 - i;
			System.out.println("Login failed, Try again");
			throw new InvalidCredException("Invalid Credentials");
		}
	}
}

class Bank {
	public void doLogin() {
		LoginPage lp = new LoginPage();
		try {
			lp.getInput();
			lp.verify();
		} catch (Exception e1) {
			System.out.println("You have 2 more attempts");

			try {
				lp.getInput();
				lp.verify();
			} catch (Exception e2) {
				System.out.println("You have last attempts");
				try {
					lp.getInput();
					lp.verify();
				} catch (Exception e3) {
					System.out.println("You have exceed the limit");

				}

			}
		}

	}

}

public class BankAccountLoginValidation {

	public static void main(String[] args) {

		Bank b = new Bank();
		b.doLogin();

	}

}

One Cathc with Multiple Exception
---------------------------------
try
{}
catch(Exception1 | Exception2 e)
{}

There should be no hierarchy

class Demo1 extends Exception {
	public Demo1(String str) {
		super(str);
	}
}

class Demo2 extends Throwable {
	public Demo2(String str) {
		super(str);
	}
}

public class OneCatchWithMultipleException {

	static void Test() throws Demo1 {
		int a = 10, b = 20;
		if (a == b) {
			throw new Demo1("A is Equal to B");
		} else {
			throw new Demo1("A is Not Equal to B");
		}
	}

	public static void main(String[] args) throws Demo1, Demo2 {

		try {
			Test();
		} catch (Demo1 | StringIndexOutOfBoundsException d) {
			d.printStackTrace();
		}

	}

}
************************************************************************************************************************************************************
MULTITHREADING
==============
->Whenevr we start running Java prog, JVM creates and assign one thread knows as main thread for the excution and its default priority is 5
->Name and Priority of the thread can be changed

Ex:
public class MainThreadDemo1 {

	public static void main(String[] args) {

		Thread thread = new Thread();

		String name1 = thread.getName();
		int priority1 = thread.getPriority();
		System.out.println("Name of the thread is: " + name1);
		System.out.println("Priority of the Main thread is: " + priority1);

		thread.setName("New Main Thread");
		thread.setPriority(4);

		String name2 = thread.getName();
		int priority2 = thread.getPriority();
		System.out.println("Name of the thread is: " + name2);
		System.out.println("Priority of the Main thread is: " + priority2);

	}

}

OUTPUT:
Name of the thread is: Thread-0
Priority of the Main thread is: 5
Name of the thread is: New Main Thread
Priority of the Main thread is: 4

Creating Thread
---------------
 Extending Thread class
 Implementing Runnable interface

Runnable Interface
  run()
Thread class implemented run()

Method 1 Steps:
Create a class and implements Runnable interface
Add method with name run

In Main method
 Create Object for the class
 Create Thread object for Thread class and pass class reference of previous step in it
 Call start method using the thread object reference[Internally Thread scheduler will call run()]

Note:
->Thread execute only run() logic
->Thread scheduler is one who control all thread execution

Ex:3 Thread creation for 3 class to perform 3 different activity paralelly
class Banking implements Runnable {

	@Override
	public void run() {

		System.out.println("BANKING ACTIVITY STARTED");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter name");
		String name = sc.next();
		System.out.println("Enter password");
		String password = sc.next();

		System.out.println("Name is: " + name);
		System.out.println("password is: " + password);
		System.out.println("BANKING ACTIVITY ENDED");

	}

}

class Gaming implements Runnable {

	@Override
	public void run() {

		System.out.println("GAMING ACTIVITY STARTED");
		System.out.println("Need for speed game");
		for (int i = 0; i < 10; i++) {
			System.out.println("Car driving in speed " + i + " KM");
		}
		System.out.println("GAMING ACTIVITY ENDED");

	}
}

class Loop implements Runnable {

	@Override
	public void run() {
		System.out.println("LOOP ACTIVITY STARTED");
		for (int i = 0; i < 5; i++) {
			System.out.println("APPU is BOSS");
		}
		System.out.println("LOOP ACTIVITY ENDED");

	}

}

public class MultithreadingDemo1 {

	public static void main(String[] args) {

		Banking b = new Banking();
		Gaming g = new Gaming();
		Loop l = new Loop();

		Thread t1 = new Thread(b);
		Thread t2 = new Thread(g);
		Thread t3 = new Thread(l);

		t1.start();
		t2.start();
		t3.start();

	}

}

OUTPUT:
BANKING ACTIVITY STARTED
GAMING ACTIVITY STARTED
LOOP ACTIVITY STARTED
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
LOOP ACTIVITY ENDED
Need for speed game
Car driving in speed 0 KM
Car driving in speed 1 KM
Car driving in speed 2 KM
Car driving in speed 3 KM
Car driving in speed 4 KM
Car driving in speed 5 KM
Car driving in speed 6 KM
Car driving in speed 7 KM
Car driving in speed 8 KM
Car driving in speed 9 KM
GAMING ACTIVITY ENDED
Enter name
appu
Enter password
appu123
Name is: appu
password is: appu123
BANKING ACTIVITY ENDED

Method 2 Steps:
Create a class and extends Thread class
Add method with name run

In Main method
 Create Object for the class
 With object reference Call start method[Internally Thread scheduler will call run()]

Ex:
class Banking1 extends Thread {

	@Override
	public void run() {

		System.out.println("BANKING ACTIVITY STARTED");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter name");
		String name = sc.next();
		System.out.println("Enter password");
		String password = sc.next();

		System.out.println("Name is: " + name);
		System.out.println("password is: " + password);
		System.out.println("BANKING ACTIVITY ENDED");

	}

}

class Gaming1 extends Thread {

	@Override
	public void run() {

		System.out.println("GAMING ACTIVITY STARTED");
		System.out.println("Need for speed game");
		for (int i = 0; i < 10; i++) {
			System.out.println("Car driving in speed " + i + " KM");
		}
		System.out.println("GAMING ACTIVITY ENDED");

	}
}

class Loop1 extends Thread {

	@Override
	public void run() {
		System.out.println("LOOP ACTIVITY STARTED");
		for (int i = 0; i < 5; i++) {
			System.out.println("APPU is BOSS");
		}
		System.out.println("LOOP ACTIVITY ENDED");

	}

}

public class CraetingThreadByExtendingThreadClass {

	public static void main(String[] args) {
		Banking1 b = new Banking1();
		Gaming1 g = new Gaming1();
		Loop1 l = new Loop1();

		b.start();
		g.start();
		l.start();
	}

}

OUTPUT:
GAMING ACTIVITY STARTED
LOOP ACTIVITY STARTED
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
LOOP ACTIVITY ENDED
BANKING ACTIVITY STARTED
Need for speed game
Car driving in speed 0 KM
Car driving in speed 1 KM
Car driving in speed 2 KM
Car driving in speed 3 KM
Car driving in speed 4 KM
Car driving in speed 5 KM
Car driving in speed 6 KM
Car driving in speed 7 KM
Car driving in speed 8 KM
Car driving in speed 9 KM
GAMING ACTIVITY ENDED
Enter name
appu
Enter password
appu123
Name is: appu
password is: appu123
BANKING ACTIVITY ENDED

Waiting for one thread to be completed before other thread complete its execution
---------------------------------------------------------------------------------
refVar.isAlive() //check is thread started and running
Ex:System.out.println(b.isAlive());

refVar.join()//make wait for this thread to complete
Ex:b.join();


Ex:Check thread b,g and l is alive or not and Main thread wait for b,g and l thread to finish exe before it terminates

class Banking2 extends Thread {

	@Override
	public void run() {

		System.out.println("BANKING ACTIVITY STARTED");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter name");
		String name = sc.next();
		System.out.println("Enter password");
		String password = sc.next();

		System.out.println("Name is: " + name);
		System.out.println("password is: " + password);
		System.out.println("BANKING ACTIVITY ENDED");

	}

}

class Gaming2 extends Thread {

	@Override
	public void run() {

		System.out.println("GAMING ACTIVITY STARTED");
		System.out.println("Need for speed game");
		for (int i = 0; i < 10; i++) {
			System.out.println("Car driving in speed " + i + " KM");
		}
		System.out.println("GAMING ACTIVITY ENDED");

	}
}

class Loop2 extends Thread {

	@Override
	public void run() {
		System.out.println("LOOP ACTIVITY STARTED");
		for (int i = 0; i < 5; i++) {
			System.out.println("APPU is BOSS");
		}
		System.out.println("LOOP ACTIVITY ENDED");

	}

}

public class MakingMainThreadToWaitForOtherThread {

	public static void main(String[] args) throws InterruptedException {

		System.out.println("Main Thread Started");
		System.out.println("Resource Opened");

		Banking2 b = new Banking2();
		Gaming2 g = new Gaming2();
		Loop2 l = new Loop2();

		// To Check b,g,l thread is alive or not
		System.out.println(b.isAlive());
		System.out.println(g.isAlive());
		System.out.println(l.isAlive());

		b.start();
		g.start();
		l.start();

		// To Check b,g,l thread is alive or not
		System.out.println(b.isAlive());
		System.out.println(g.isAlive());
		System.out.println(l.isAlive());

		// Main thread wait for b,g and l thread
		b.join();
		g.join();
		l.join();

		System.out.println("Resource Closed");
		System.out.println("Main Thread Ended");

	}

}

OUTPUT:
Main Thread Started
Resource Opened
false
false
false
true
true
true
GAMING ACTIVITY STARTED
Need for speed game
BANKING ACTIVITY STARTED
LOOP ACTIVITY STARTED
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
LOOP ACTIVITY ENDED
Car driving in speed 0 KM
Car driving in speed 1 KM
Car driving in speed 2 KM
Car driving in speed 3 KM
Car driving in speed 4 KM
Car driving in speed 5 KM
Car driving in speed 6 KM
Car driving in speed 7 KM
Car driving in speed 8 KM
Car driving in speed 9 KM
GAMING ACTIVITY ENDED
Enter name
appu
Enter password
appu123
Name is: appu
password is: appu123
BANKING ACTIVITY ENDED
Resource Closed
Main Thread Ended

Within one run(), seperate thread execute seperate methods
----------------------------------------------------------
Ex:Seperate Thread Executes Seperate Methods Within One RunMethod

class MultiTasking implements Runnable {

	@Override
	public void run() {
		String threadname = Thread.currentThread().getName();
		if (threadname.equals("BANK")) {
			banking();
		} else if (threadname.equals("GAME")) {
			carGaming();
		} else {
			looping();
		}

	}

	public void banking() {
		System.out.println("BANKING ACTIVITY STARTED");
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter name");
		String name = sc.next();
		System.out.println("Enter password");
		String password = sc.next();

		System.out.println("Name is: " + name);
		System.out.println("password is: " + password);
		System.out.println("BANKING ACTIVITY ENDED");
	}

	public void carGaming() {
		System.out.println("GAMING ACTIVITY STARTED");
		System.out.println("Need for speed game");
		for (int i = 0; i < 10; i++) {
			System.out.println("Car driving in speed " + i + " KM");
		}
		System.out.println("GAMING ACTIVITY ENDED");
	}

	public void looping() {
		System.out.println("LOOP ACTIVITY STARTED");
		for (int i = 0; i < 5; i++) {
			System.out.println("APPU is BOSS");
		}
		System.out.println("LOOP ACTIVITY ENDED");
	}

}

public class SeperateThreadExecutesSeperateMethodsWithinOneRunMethod {

	public static void main(String[] args) throws InterruptedException {

		System.out.println("Main STARTED");
		MultiTasking m = new MultiTasking();
		Thread t1 = new Thread(m);
		Thread t2 = new Thread(m);
		Thread t3 = new Thread(m);

		t1.setName("BANK");
		t2.setName("GAME");
		t3.setName("LOOP");

		t1.start();
		t2.start();
		t3.start();

		t1.join();
		t2.join();
		t3.join();

		System.out.println("Main ENDED");
	}

}

OUTPUT:
Main STARTED
BANKING ACTIVITY STARTED
LOOP ACTIVITY STARTED
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
APPU is BOSS
LOOP ACTIVITY ENDED
GAMING ACTIVITY STARTED
Need for speed game
Car driving in speed 0 KM
Car driving in speed 1 KM
Car driving in speed 2 KM
Car driving in speed 3 KM
Car driving in speed 4 KM
Car driving in speed 5 KM
Car driving in speed 6 KM
Car driving in speed 7 KM
Car driving in speed 8 KM
Car driving in speed 9 KM
GAMING ACTIVITY ENDED
Enter name
appu
Enter password
appu123
Name is: appu
password is: appu123
BANKING ACTIVITY ENDED
Main ENDED

Making one thread to exe and complete the run() -synchronized()
---------------------------------------------------------------
->If we make method as synchronized then that method can be used by one thread at a time, until that thread finish executing the method other thread will be in waiting state
->If any method is synchronized, then once any thread start executing run() then all other thread should wait untill it finish the execution.
->Can be applied to method and block


Ex:Boy star using bathroom, all other thread girl and others should wait untill he finish

class BathRoom implements Runnable {

	@Override
	synchronized public void run() {

		System.out.println(Thread.currentThread().getName() + " entered");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName() + " using");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread().getName() + " finished");
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}

public class SynchronizedmethodDemo {

	public static void main(String[] args) {

		BathRoom b = new BathRoom();
		Thread t1 = new Thread(b);
		Thread t2 = new Thread(b);
		Thread t3 = new Thread(b);

		t1.setName("BOY");
		t2.setName("GIRL");
		t3.setName("OTHERS");

		t1.start();
		t2.start();
		t3.start();

	}

}

OUTPUT:
BOY entered
BOY using
BOY finished
OTHERS entered
OTHERS using
OTHERS finished
GIRL entered
GIRL using
GIRL finished

->If we want to apply synchornization to spefic int then use sync block instead of applying sync to entire method

Ex:All 3 childs can exe at same time for entering parking lot, but one can use parking lot at a time

class SynchronizedBlock implements Runnable {

	@Override
	public void run() {

		System.out.println(Thread.currentThread().getName() + " entered parking lot");
		try {
			Thread.sleep(3000);
		} catch (InterruptedException e) {

		}

		synchronized (this) {
			System.out.println(Thread.currentThread().getName() + " parking the car");
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {

			}

			System.out.println(Thread.currentThread().getName() + " came out of the car");
			try {
				Thread.sleep(3000);
			} catch (InterruptedException e) {

			}
		}

	}

}

public class SynchronizedBlockDemo {

	public static void main(String[] args) {

		SynchronizedBlock sb = new SynchronizedBlock();
		Thread t1 = new Thread(sb); // Creating thread for executing logic of run method inside SynchronizedBlock
									// class
		Thread t2 = new Thread(sb);
		Thread t3 = new Thread(sb);

		t1.setName("Child 1");
		t2.setName("Child 2");
		t3.setName("Child 3");

		t1.start();
		t2.start();
		t3.start();

	}

}

OUTPUT:
Child 2 entered parking lot
Child 3 entered parking lot
Child 1 entered parking lot
Child 1 parking the car
Child 1 came out of the car
Child 2 parking the car
Child 2 came out of the car
Child 3 parking the car
Child 3 came out of the car

Thread State
------------
->In running state at any point of time there will be one thread
->Thread cant be intrupted while its in running state
new>ready[runnable]>running>dead
waiting/blocked/sleep

************************************************************************************************************************************************************
PACKAGES
========
->If any class present in other package then we need to import before use
************************************************************************************************************************************************************
COLLECTIONS
===========

Hierarchy
---------
Iterable->Collection->List/Queue/Set

List->Array List/LinkedList

Queue->DQueue[ArrayDQueue]/PriorityQueue

Set->SortedSet[TreeSet]/HashSet[LinkedHashSet]


ArrayList
---------
->Follow dynamic array ds/Implements list interface/Index based/Order of Insertion preserved/Allow duplicates/Any number of null can be added
->Takes more time for insertion and deletion since shifting happens when try to insert elem at specific index, solution is go wit linked list
->Add elem at rear end

Ex:
public class Collection1 {

	public static void main(String[] args) {

		List list = new ArrayList();
		list.add("Appu");
		list.add(10);
		list.add(12.33f);
		list.add(null);
		list.add(null);
		list.add("Appu");

		System.out.println(list);
	}

}


OUTPUT:
[Appu, 10, 12.33, null, null, Appu]

Linked List
-----------
->Can be added elem at first,last,any specific index
->Follow doubly linked list DS
->Good for insertion and deletion
->Implements list and DQuue interface/Index based/Order of Insertion preserved/Allow duplicates/Any number of null can be added

Ex:

public class Collection1 {

	public static void main(String[] args) {

		LinkedList list = new LinkedList();
		list.add("Appu");
		list.add(10);
		list.add(12.33f);
		list.add(null);
		list.add(null);
		list.add("Appu");
		list.addFirst("Rajkumar");
		list.addLast("Appu kumar");
		System.out.println(list.peekFirst());
		System.out.println(list);
	}

}


OUTPUT:
Rajkumar
[Rajkumar, Appu, 10, 12.33, null, null, Appu, Appu kumar]

peekFirst():return first elem
pollFirst():return frst elem and also rmeove from list

ArrayDQueue
-----------
->Double ended Q/Not index based/Allow duplicates/Not allow null elements/Insetion order preserved
->Perform operation on rear and front end

Ex:

		ArrayDeque a = new ArrayDeque();
		a.add("Appu");
		a.add("Appu");
		a.add(100);
		//a.add(null);// java.lang.NullPointerException
		///a.add(null);// java.lang.NullPointerException
		System.out.println(a);

OUTPUT:
[Appu, Appu, 100]

PriorityQueue
--------------
->Not index based/allow duplicates/not follow insertion order[priority order]/not allow null
->Follow minumum heap DS
->Can store same form of elements, only int or only string,....else class cast exception

Ex:
		PriorityQueue p=new PriorityQueue();
		p.add(100);
		p.add(101);
		p.add(100);
                p.add("Appu"); //classcastexception
		//p.add(null);
		System.out.println(p);

OUTPUT:
[100, 101, 100]



